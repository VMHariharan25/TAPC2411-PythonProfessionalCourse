\chapter{Introduction to Python Programming}

\section{Introduction}

\subsection{Programming Language}
A programming language is a formal language comprising a set of instructions that produce various kinds of output. It allows programmers to communicate instructions to a computer system, enabling it to perform specific tasks or functions. Programming languages are used to create software, websites, applications, and other computational solutions.

Examples of programming languages include \texttt{Python}, \texttt{Java}, \texttt{C++}, \texttt{JavaScript}, \texttt{Ruby}, and many more. Each language has its own syntax, semantics, and rules that govern how instructions are written and executed.

\subsection{Algorithms}
An \textbf{algorithm} is a step-by-step procedure or set of rules designed to solve a specific problem or perform a particular task. It is a finite sequence of well-defined, unambiguous instructions that, when followed, lead to a desired outcome or solution. Algorithms can be expressed in various forms, including natural language, pseudocode, flowcharts, or programming languages.

In computer science, algorithms are fundamental to solving computational problems efficiently. They provide a blueprint for writing computer programs and are essential for tasks such as sorting data, searching for information, performing mathematical operations, and optimizing processes.

\textbf{Key characteristics of algorithms:}
\begin{enumerate}
    \item \textbf{Input:} The algorithm receives data or input values on which it operates.
    \item \textbf{Output:} The algorithm produces a result or output based on the input and the operations performed.
    \item \textbf{Determinism:} Each step of the algorithm is precisely defined and produces the same result when executed with the same input.
    \item \textbf{Finiteness:} The algorithm has a finite number of steps, meaning it eventually terminates.
    \item \textbf{Effectiveness:} Each step of the algorithm must be clear and executable within finite time and space constraints.
\end{enumerate}

Algorithms are used extensively in various fields, including computer science, mathematics, engineering, and everyday problem-solving tasks. They serve as the foundation for designing efficient software systems, algorithms for data analysis, artificial intelligence, and more.

\subsection{Types of Programming Language}
Programming languages can be categorized into several types based on various criteria such as their level of abstraction, paradigm, purpose, and domain of application. Here are some common types:

\begin{enumerate}
    \item \textbf{Low-level languages:}
    \begin{itemize}
        \item \textbf{Machine Language:} The lowest-level programming language consisting of binary code understood directly by the computer’s hardware.
        \item \textbf{Assembly Language:} Uses mnemonic codes to represent machine instructions, making it more readable than machine language but still closely tied to the hardware architecture.
    \end{itemize}
    \item \textbf{High-level languages:}
    \begin{itemize}
        \item \textbf{Procedural Languages:} Focus on describing a sequence of steps to solve a problem. Examples: \texttt{C}, \texttt{Pascal}, \texttt{BASIC}.
        \item \textbf{Object-Oriented Languages:} Organize code into objects that interact with each other, emphasizing encapsulation, inheritance, and polymorphism. Examples: \texttt{Java}, \texttt{C++}, \texttt{Python}.
        \item \textbf{Functional Languages:} Treat computation as the evaluation of mathematical functions and emphasize immutability and declarative programming. Examples: \texttt{Haskell}, \texttt{Lisp}, \texttt{Scala}.
        \item \textbf{Scripting Languages:} Designed for quick and easy development of small to medium-sized programs. Examples: \texttt{Python}, \texttt{Ruby}, \texttt{JavaScript}.
    \end{itemize}
    \item \textbf{Domain-specific languages (DSLs):}
    \begin{itemize}
        \item \textbf{Markup Languages:} Used to annotate text for formatting or semantic information. Examples: \texttt{HTML}, \texttt{XML}, \texttt{Markdown}.
        \item \textbf{Query Languages:} For querying and manipulating databases or data sources. Examples: \texttt{SQL}, \texttt{XPath}.
        \item \textbf{Statistical Languages:} For statistical analysis and data manipulation. Examples: \texttt{R}, \texttt{MATLAB}.
    \end{itemize}
    \item \textbf{Functional purpose:}
    \begin{itemize}
        \item \textbf{General-purpose languages:} Versatile and used for a wide range of applications. Examples: \texttt{Python}, \texttt{Java}, \texttt{C++}.
        \item \textbf{Domain-specific languages:} Tailored to a specific application domain. Examples: \texttt{SQL}, \texttt{HTML/CSS}, \texttt{VHDL}.
    \end{itemize}
    \item \textbf{Compiled vs. interpreted languages:}
    \begin{itemize}
        \item \textbf{Compiled Languages:} Code is translated into machine code before execution. Examples: \texttt{C}, \texttt{C++}, \texttt{Rust}.
        \item \textbf{Interpreted Languages:} Code is executed line by line by an interpreter. Examples: \texttt{Python}, \texttt{Ruby}, \texttt{JavaScript}.
    \end{itemize}
    \item \textbf{Imperative vs. Declarative languages:}
    \begin{itemize}
        \item \textbf{Imperative Languages:} Programs are composed of statements that change a program’s state. Examples: \texttt{C}, \texttt{Java}, \texttt{Python}.
        \item \textbf{Declarative Languages:} Programs describe the desired result without specifying the exact steps. Examples: \texttt{SQL}, \texttt{HTML/CSS}, \texttt{Prolog}.
    \end{itemize}
\end{enumerate}

\section{Compilers}

\begin{enumerate}
    \item \textbf{Lexical Analysis (Scanning):}
    \begin{itemize}
        \item Breaks the source code into tokens or lexemes.
        \item The lexer (scanner) reads the source code character by character and groups them into tokens.
        \item Comments and whitespace are usually discarded.
    \end{itemize}
    \item \textbf{Syntax Analysis (Parsing):}
    \begin{itemize}
        \item Analyzes the structure of the source code to ensure it conforms to syntax rules.
        \item The parser uses a grammar specification to check if the tokens form valid statements and expressions.
        \item Generates a parse tree or abstract syntax tree (AST).
    \end{itemize}
    \item \textbf{Semantic Analysis:}
    \begin{itemize}
        \item Verifies the meaning of the source code beyond its syntax.
        \item Checks for semantic errors, such as type mismatches or undefined variables.
        \item Involves symbol table management.
    \end{itemize}
    \item \textbf{Intermediate Code Generation:}
    \begin{itemize}
        \item Translates the source code into an intermediate representation (IR).
        \item May involve translating the AST into a lower-level representation.
    \end{itemize}
    \item \textbf{Optimization:}
    \begin{itemize}
        \item Applies optimization techniques to improve code efficiency.
        \item Examples: constant folding, dead code elimination, loop optimization.
    \end{itemize}
    \item \textbf{Code Generation:}
    \begin{itemize}
        \item Translates the optimized intermediate code into machine code.
        \item Register allocation and instruction scheduling may occur.
    \end{itemize}
    \item \textbf{Linking (for multi-file programs):}
    \begin{itemize}
        \item Combines object files into a single executable or library.
        \item Resolves external references and performs address binding.
    \end{itemize}
\end{enumerate}

Each stage of the compiler transforms the source code into executable code efficiently. The resulting executable can then be run on the target platform.

\section{Interpreter Language}

\begin{enumerate}
    \item \textbf{Lexical Analysis:}
    \begin{itemize}
        \item Reads the source code character by character and groups them into tokens.
        \item Tokens represent the smallest units, such as keywords, identifiers, operators, and literals.
        \item Comments and whitespace are typically ignored.
    \end{itemize}
    \item \textbf{Parsing:}
    \begin{itemize}
        \item Analyzes the structure of the source code to ensure it conforms to syntax rules.
        \item Checks if the tokens form valid statements and expressions.
        \item May generate an abstract syntax tree (AST).
    \end{itemize}
    \item \textbf{Semantic Analysis:}
    \begin{itemize}
        \item Verifies the meaning of the source code beyond its syntax.
        \item Checks for semantic errors.
        \item Involves symbol table management.
    \end{itemize}
    \item \textbf{Code Execution:}
    \begin{itemize}
        \item Executes the parsed code directly without a separate code generation stage.
        \item Interprets the AST or intermediate representation.
        \item May use strategies like bytecode interpretation or just-in-time (JIT) compilation.
    \end{itemize}
\end{enumerate}

Unlike compilers, interpreters do not generate machine code but execute the code directly.

\begin{table}[H]
    \centering 
    \caption{Difference Between Compiler and Interpreter}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{Compiler} & \textbf{Interpreter} \\
        \hline
        Translates entire program to machine code before execution. & Translates code line by line and executes it simultaneously. \\
        \hline
        Produces intermediate object code or executable file. & Does not produce an intermediate object code or executable file. \\
        \hline
        Typically generates faster-executing code. & Generally slower as it executes code directly. \\
        \hline
        Detects all syntax and semantic errors before execution. & May detect errors at runtime during interpretation. \\
        \hline
        Requires a separate compilation stage before execution. & Does not require a separate compilation stage. \\
        \hline
        Examples include GCC (GNU Compiler Collection), Clang. & Examples include Python interpreter, JavaScript interpreter. \\
        \hline
    \end{tabular}
\end{table}


\begin{table}[H]
    \caption{Differences Between Procedural, Object-Oriented, and Functional Programming}
    
    \begin{tabular}{|p{0.28\textwidth}|p{0.33\textwidth}|p{0.33\textwidth}|}
        \hline
        \textbf{Procedural Programming} & \textbf{Object-Oriented Programming} & \textbf{Functional Programming} \\
        \hline
        Focuses on procedures or functions that operate on data. & Organizes code into objects that encapsulate data and behavior. & Emphasizes mathematical functions and immutable data. \\
        \hline
        Data and procedures are separate entities. & Data and behavior are encapsulated within objects. & Functions are first-class citizens and can be passed as arguments or returned. \\
        \hline
        Languages: C, Pascal. & Languages: Java, C++, Python. & Languages: Haskell, Lisp, Clojure. \\
        \hline
        Follows a top-down approach to problem-solving. & Follows a bottom-up approach with focus on reusability and modularity. & Follows a declarative approach; functions describe what should be done. \\
        \hline
        Less emphasis on code reusability and scalability. & Promotes code reusability through inheritance, polymorphism, encapsulation. & Encourages code reusability through higher-order functions and immutability. \\
        \hline
    \end{tabular}
\end{table}